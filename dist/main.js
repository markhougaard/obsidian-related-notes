/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RelatedNotesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// view.ts
var import_obsidian = require("obsidian");
var VIEW_TYPE_RELATED_NOTES = "related-notes-view";
var RelatedNotesView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_RELATED_NOTES;
  }
  getIcon() {
    return "link";
  }
  getDisplayText() {
    return "Related Notes";
  }
  async onOpen() {
    await this.update();
  }
  async update() {
    const container = this.contentEl;
    container.empty();
    const wrapper = container.createDiv({ cls: "related-notes-container" });
    wrapper.createEl("h4", { text: "Related Notes", cls: "nav-file-title", attr: { style: "margin-bottom: 10px; padding-left: 10px;" } });
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      wrapper.createEl("p", { text: "No active file.", cls: "related-notes-empty" });
      return;
    }
    const loadingEl = wrapper.createDiv({ cls: "related-notes-loading" });
    loadingEl.createEl("span", { cls: "loading-spinner" });
    loadingEl.createSpan({ text: " Finding related notes..." });
    let related = [];
    try {
      await this.plugin.searchService.indexNote(activeFile);
      related = this.plugin.searchService.findRelated(activeFile, this.plugin.settings.maxRelatedNotes);
      loadingEl.remove();
      if (related.length === 0) {
        wrapper.createEl("p", { text: "No related notes found.", cls: "related-notes-empty" });
        return;
      }
    } catch (e) {
      loadingEl.remove();
      const errorContainer = wrapper.createDiv({ cls: "related-notes-error-container" });
      errorContainer.createEl("p", { text: `Error: ${e.message}`, cls: "related-notes-error" });
      const retryBtn = errorContainer.createEl("button", { text: "Retry" });
      retryBtn.onclick = () => this.update();
      console.error("Related Notes Error:", e);
      return;
    }
    const list = wrapper.createEl("div", { cls: "related-notes-list" });
    const seenPaths = /* @__PURE__ */ new Set();
    for (const item of related) {
      if (seenPaths.has(item.file.path))
        continue;
      seenPaths.add(item.file.path);
      const itemDiv = list.createDiv({ cls: "related-note-item nav-file-title" });
      itemDiv.createEl("span", {
        text: item.file.basename,
        cls: "nav-file-title-content"
      });
      itemDiv.createEl("span", {
        text: `${Math.round(item.score * 100)}%`,
        cls: "related-note-score",
        attr: { style: "margin-left: auto; color: var(--text-muted); font-size: 0.8em;" }
      });
      itemDiv.addEventListener("click", (e) => {
        e.preventDefault();
        this.app.workspace.openLinkText(item.file.path, "", true);
      });
      itemDiv.addEventListener("mouseenter", () => {
        itemDiv.addClass("is-active");
      });
      itemDiv.addEventListener("mouseleave", () => {
        itemDiv.removeClass("is-active");
      });
    }
  }
  async onClose() {
  }
};

// semantic_search.ts
var import_obsidian3 = require("obsidian");

// ollama_client.ts
var import_obsidian2 = require("obsidian");
var OllamaClient = class {
  constructor(config, debugMode = false) {
    this.config = config;
    this.debugMode = debugMode;
  }
  setDebugMode(debugMode) {
    this.debugMode = debugMode;
  }
  async generateEmbedding(text, title, retries = 3) {
    const url = `${this.config.baseUrl}/api/embeddings`;
    const sanitizedText = this.sanitizeText(text);
    const maxLength = 32e3;
    const truncatedText = sanitizedText.length > maxLength ? sanitizedText.substring(0, maxLength) : sanitizedText;
    for (let attempt = 0; attempt <= retries; attempt++) {
      let response;
      try {
        response = await (0, import_obsidian2.requestUrl)({
          url,
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            model: this.config.model,
            prompt: truncatedText
          }),
          throw: false
          // Don't throw on non-200 status
        });
      } catch (error) {
        console.error(`Request failed completely (attempt ${attempt + 1}/${retries + 1}):`, error);
        if (attempt < retries) {
          const delay = Math.pow(2, attempt) * 1e3;
          console.log(`Retrying in ${delay}ms...`);
          await new Promise((resolve) => setTimeout(resolve, delay));
          continue;
        }
        console.error("Text length:", text.length, "Truncated to:", truncatedText.length);
        console.error("Model:", this.config.model);
        console.error("URL:", url);
        throw new Error(`Failed to connect to Ollama after ${retries + 1} attempts: ${error.message}`);
      }
      if (response.status !== 200) {
        const errorText = response.text;
        if (this.debugMode)
          console.error(`Ollama API error (attempt ${attempt + 1}/${retries + 1}):`, errorText);
        if (errorText.includes("EOF") || errorText.includes("connection")) {
          if (attempt < retries) {
            const delay = Math.pow(2, attempt) * 1e3;
            if (this.debugMode)
              console.log(`Transient error detected. Retrying in ${delay}ms...`);
            await new Promise((resolve) => setTimeout(resolve, delay));
            continue;
          } else {
            if (this.debugMode)
              console.log("Persistent EOF error. Attempting Safe Mode (reduced context)...");
            try {
              const safeLength = 2e3;
              const safeText = sanitizedText.substring(0, safeLength);
              const safeResponse = await (0, import_obsidian2.requestUrl)({
                url,
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  model: this.config.model,
                  prompt: safeText
                }),
                throw: false
              });
              if (safeResponse.status === 200) {
                const data2 = safeResponse.json;
                if (data2.embedding && Array.isArray(data2.embedding)) {
                  if (this.debugMode)
                    console.log("Safe Mode succeeded!");
                  return data2.embedding;
                }
              } else {
                if (this.debugMode)
                  console.error(`Safe Mode failed with status ${safeResponse.status}: ${safeResponse.text}`);
              }
            } catch (safeError) {
              if (this.debugMode)
                console.error("Safe Mode exception:", safeError);
            }
            if (title) {
              if (this.debugMode)
                console.log(`Safe Mode failed. Attempting Title Only Mode for "${title}"...`);
              try {
                const titleResponse = await (0, import_obsidian2.requestUrl)({
                  url,
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    model: this.config.model,
                    prompt: `Note title: ${title}`
                  }),
                  throw: false
                });
                if (titleResponse.status === 200) {
                  const data2 = titleResponse.json;
                  if (data2.embedding && Array.isArray(data2.embedding)) {
                    if (this.debugMode)
                      console.log("Title Only Mode succeeded!");
                    return data2.embedding;
                  }
                } else {
                  if (this.debugMode)
                    console.error(`Title Only Mode failed with status ${titleResponse.status}: ${titleResponse.text}`);
                }
              } catch (titleError) {
                if (this.debugMode)
                  console.error("Title Only Mode exception:", titleError);
              }
            }
          }
        }
        if (this.debugMode) {
          console.error("Response status:", response.status);
          console.error("Response headers:", response.headers);
        }
        throw new Error(`Ollama API error: ${response.status} - ${errorText}`);
      }
      const data = response.json;
      if (!data.embedding || !Array.isArray(data.embedding)) {
        console.error("Invalid response format:", data);
        throw new Error("Invalid embedding response from Ollama");
      }
      return data.embedding;
    }
    throw new Error("Failed to generate embedding after all retries");
  }
  async testConnection() {
    try {
      const url = `${this.config.baseUrl}/api/tags`;
      const response = await (0, import_obsidian2.requestUrl)({ url, method: "GET" });
      return response.status === 200;
    } catch (error) {
      console.error("Ollama connection test failed:", error);
      return false;
    }
  }
  sanitizeText(text) {
    return text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, "");
  }
};

// semantic_search.ts
var SemanticSearchService = class {
  constructor(vault, ollamaConfig, format = "json", debugMode = false) {
    this.vectors = [];
    this.vectorStorePathJson = (0, import_obsidian3.normalizePath)(".obsidian/plugins/obsidian-related-notes/vectors.json");
    this.vectorStorePathBinary = (0, import_obsidian3.normalizePath)(".obsidian/plugins/obsidian-related-notes/vectors.bin");
    this.isIndexing = false;
    this.currentProgress = 0;
    this.totalFiles = 0;
    this.onIndexingProgress = null;
    this.abortController = null;
    this.vault = vault;
    this.ollamaClient = new OllamaClient(ollamaConfig, debugMode);
    this.format = format;
    this.debugMode = debugMode;
  }
  setFormat(format) {
    this.format = format;
  }
  setDebugMode(debugMode) {
    this.debugMode = debugMode;
    this.ollamaClient.setDebugMode(debugMode);
  }
  async testConnection() {
    return await this.ollamaClient.testConnection();
  }
  async loadVectors() {
    this.vectors = [];
    if (this.format === "binary") {
      if (await this.vault.adapter.exists(this.vectorStorePathBinary)) {
        await this.loadVectorsBinary();
        return;
      }
      if (await this.vault.adapter.exists(this.vectorStorePathJson)) {
        await this.loadVectorsJson();
      }
    } else {
      if (await this.vault.adapter.exists(this.vectorStorePathJson)) {
        await this.loadVectorsJson();
      }
    }
  }
  async loadVectorsJson() {
    try {
      const content = await this.vault.adapter.read(this.vectorStorePathJson);
      this.vectors = JSON.parse(content);
      console.log(`Loaded ${this.vectors.length} vectors from JSON`);
    } catch (error) {
      console.error("Failed to load JSON vectors:", error);
      this.vectors = [];
    }
  }
  async loadVectorsBinary() {
    try {
      const buffer = await this.vault.adapter.readBinary(this.vectorStorePathBinary);
      const view = new DataView(buffer);
      let offset = 0;
      const magic = String.fromCharCode(view.getUint8(offset), view.getUint8(offset + 1), view.getUint8(offset + 2), view.getUint8(offset + 3));
      offset += 4;
      if (magic !== "VEC1") {
        throw new Error("Invalid binary vector file format");
      }
      const numVectors = view.getUint32(offset, true);
      offset += 4;
      const dimension = view.getUint32(offset, true);
      offset += 4;
      const decoder = new TextDecoder();
      for (let i = 0; i < numVectors; i++) {
        const pathLen = view.getUint32(offset, true);
        offset += 4;
        const pathBytes = new Uint8Array(buffer, offset, pathLen);
        const path = decoder.decode(pathBytes);
        offset += pathLen;
        const mtime = view.getFloat64(offset, true);
        offset += 8;
        const embedding = new Float32Array(dimension);
        for (let j = 0; j < dimension; j++) {
          embedding[j] = view.getFloat32(offset, true);
          offset += 4;
        }
        this.vectors.push({
          path,
          mtime,
          embedding: Array.from(embedding)
          // Convert back to number[] for compatibility
        });
      }
      console.log(`Loaded ${this.vectors.length} vectors from Binary`);
    } catch (error) {
      console.error("Failed to load binary vectors:", error);
      this.vectors = [];
    }
  }
  async saveVectors() {
    try {
      const dir = this.vectorStorePathJson.substring(0, this.vectorStorePathJson.lastIndexOf("/"));
      if (!await this.vault.adapter.exists(dir)) {
        await this.vault.adapter.mkdir(dir);
      }
      if (this.format === "binary") {
        await this.saveVectorsBinary();
      } else {
        await this.saveVectorsJson();
      }
    } catch (error) {
      console.error("Failed to save vectors:", error);
      throw error;
    }
  }
  async saveVectorsJson() {
    const data = JSON.stringify(this.vectors, null, 2);
    await this.vault.adapter.write(this.vectorStorePathJson, data);
    console.log(`Saved ${this.vectors.length} vectors to JSON`);
  }
  async saveVectorsBinary() {
    if (this.vectors.length === 0)
      return;
    const dimension = this.vectors[0].embedding.length;
    const encoder = new TextEncoder();
    let size = 4 + 4 + 4;
    const vectorData = this.vectors.map((v) => {
      const pathBytes = encoder.encode(v.path);
      size += 4 + pathBytes.length + 8 + dimension * 4;
      return { ...v, pathBytes };
    });
    const buffer = new ArrayBuffer(size);
    const view = new DataView(buffer);
    let offset = 0;
    view.setUint8(offset++, "V".charCodeAt(0));
    view.setUint8(offset++, "E".charCodeAt(0));
    view.setUint8(offset++, "C".charCodeAt(0));
    view.setUint8(offset++, "1".charCodeAt(0));
    view.setUint32(offset, this.vectors.length, true);
    offset += 4;
    view.setUint32(offset, dimension, true);
    offset += 4;
    for (const v of vectorData) {
      view.setUint32(offset, v.pathBytes.length, true);
      offset += 4;
      new Uint8Array(buffer, offset, v.pathBytes.length).set(v.pathBytes);
      offset += v.pathBytes.length;
      view.setFloat64(offset, v.mtime, true);
      offset += 8;
      for (let i = 0; i < dimension; i++) {
        view.setFloat32(offset, v.embedding[i], true);
        offset += 4;
      }
    }
    await this.vault.adapter.writeBinary(this.vectorStorePathBinary, buffer);
    console.log(`Saved ${this.vectors.length} vectors to Binary (${size} bytes)`);
    if (await this.vault.adapter.exists(this.vectorStorePathJson)) {
      await this.vault.adapter.remove(this.vectorStorePathJson);
      console.log("Removed legacy vectors.json file");
    }
  }
  async clearIndex() {
    this.vectors = [];
    if (await this.vault.adapter.exists(this.vectorStorePathBinary)) {
      await this.vault.adapter.remove(this.vectorStorePathBinary);
    }
    if (await this.vault.adapter.exists(this.vectorStorePathJson)) {
      await this.vault.adapter.remove(this.vectorStorePathJson);
    }
    console.log("Index cleared");
  }
  async generateEmbedding(text, title) {
    return await this.ollamaClient.generateEmbedding(text, title);
  }
  preprocessContent(content) {
    let clean = content.replace(/```dataview[\s\S]*?```/g, "");
    clean = clean.replace(/```dataviewjs[\s\S]*?```/g, "");
    clean = clean.replace(/```excalidraw[\s\S]*?```/g, "");
    clean = clean.replace(/## Excalidraw Data[\s\S]*$/, "");
    return clean;
  }
  async indexNote(file) {
    const existingIndex = this.vectors.findIndex((v) => v.path === file.path);
    const existingVector = this.vectors[existingIndex];
    if (existingVector && existingVector.mtime === file.stat.mtime) {
      return;
    }
    const content = await this.vault.read(file);
    const cleanedContent = this.preprocessContent(content);
    const embedding = await this.generateEmbedding(cleanedContent, file.basename);
    if (existingIndex >= 0) {
      this.vectors[existingIndex] = {
        path: file.path,
        embedding,
        mtime: file.stat.mtime
      };
    } else {
      const doubleCheckIndex = this.vectors.findIndex((v) => v.path === file.path);
      if (doubleCheckIndex >= 0) {
        this.vectors[doubleCheckIndex] = {
          path: file.path,
          embedding,
          mtime: file.stat.mtime
        };
      } else {
        this.vectors.push({
          path: file.path,
          embedding,
          mtime: file.stat.mtime
        });
      }
    }
  }
  cancelIndexing() {
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
      this.isIndexing = false;
      console.log("Indexing cancelled by user");
    }
  }
  async indexAll(files) {
    if (this.isIndexing) {
      console.log("Indexing already in progress");
      return;
    }
    this.isIndexing = true;
    this.abortController = new AbortController();
    const signal = this.abortController.signal;
    await this.loadVectors();
    let changed = false;
    let successCount = 0;
    let errorCount = 0;
    const failedFiles = [];
    try {
      let processedCount = 0;
      this.totalFiles = files.length;
      for (const file of files) {
        processedCount++;
        this.currentProgress = processedCount;
        if (this.onIndexingProgress)
          this.onIndexingProgress(processedCount, files.length);
        if (processedCount % 5 === 0) {
          await new Promise((resolve) => setTimeout(resolve, 0));
        }
        if (signal.aborted) {
          throw new Error("Indexing cancelled");
        }
        const existing = this.vectors.find((v) => v.path === file.path);
        if (!existing || existing.mtime !== file.stat.mtime) {
          console.log(`Indexing ${file.path}...`);
          try {
            await this.indexNote(file);
            changed = true;
            successCount++;
            if (successCount % 10 === 0) {
              await this.saveVectors();
            }
          } catch (error) {
            console.error(`Failed to index ${file.path}:`, error.message);
            const content = await this.vault.read(file);
            console.log(`Failed note content snippet: "${content.substring(0, 100)}..."`);
            failedFiles.push(file.path);
            errorCount++;
          }
        } else {
          if (this.debugMode) {
            console.log(`Skipping ${file.path}: Up to date (mtime: ${existing.mtime} === ${file.stat.mtime})`);
          }
        }
      }
      if (successCount > 0) {
        await this.saveVectors();
      }
      const currentFilePaths = new Set(files.map((f) => f.path));
      const initialVectorCount = this.vectors.length;
      this.vectors = this.vectors.filter((v) => currentFilePaths.has(v.path));
      const prunedCount = initialVectorCount - this.vectors.length;
      if (prunedCount > 0) {
        console.log(`Pruned ${prunedCount} deleted notes from index.`);
        await this.saveVectors();
      }
      if (this.debugMode)
        console.log(`Indexing complete: ${successCount} succeeded, ${errorCount} failed, ${prunedCount} pruned`);
      if (failedFiles.length > 0 && this.debugMode) {
        console.log("Failed files:", failedFiles);
      }
    } catch (error) {
      if (error.message === "Indexing cancelled") {
        if (this.debugMode)
          console.log("Indexing cancelled.");
        if (successCount > 0) {
          if (this.debugMode)
            console.log("Saving partial progress...");
          await this.saveVectors();
        }
      } else {
        console.error("Indexing failed:", error);
      }
    } finally {
      this.isIndexing = false;
      this.abortController = null;
    }
  }
  cosineSimilarity(a, b) {
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }
  findRelated(file, topK = 5) {
    const targetVector = this.vectors.find((v) => v.path === file.path);
    if (!targetVector)
      return [];
    const scores = this.vectors.filter((v) => v.path !== file.path).map((v) => ({
      path: v.path,
      score: this.cosineSimilarity(targetVector.embedding, v.embedding)
    })).sort((a, b) => b.score - a.score).slice(0, topK);
    return scores.map((s) => {
      const relatedFile = this.vault.getAbstractFileByPath(s.path);
      return relatedFile instanceof import_obsidian3.TFile ? { file: relatedFile, score: s.score } : null;
    }).filter((x) => x !== null);
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  ollamaUrl: "http://localhost:11434",
  ollamaModel: "nomic-embed-text",
  vectorFormat: "json",
  maxRelatedNotes: 5,
  debugMode: false
};
var RelatedNotesPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    const ollamaConfig = {
      baseUrl: this.settings.ollamaUrl,
      model: this.settings.ollamaModel
    };
    this.searchService = new SemanticSearchService(this.app.vault, ollamaConfig, this.settings.vectorFormat, this.settings.debugMode);
    this.searchService.loadVectors();
    this.addSettingTab(new RelatedNotesSettingTab(this.app, this));
    this.registerView(
      VIEW_TYPE_RELATED_NOTES,
      (leaf) => new RelatedNotesView(leaf, this)
    );
    this.addRibbonIcon("dice", "Find Related Notes", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-related-notes-view",
      name: "Open Related Notes View",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "index-all-notes",
      name: "Index All Notes",
      callback: async () => {
        const files = this.app.vault.getMarkdownFiles();
        try {
          await this.searchService.indexAll(files);
          this.settings.lastIndexedDate = Date.now();
          await this.saveSettings();
          new import_obsidian4.Notice("Indexing complete!");
        } catch (error) {
          new import_obsidian4.Notice(`Indexing failed: ${error.message}`);
          console.error("Indexing error:", error);
        }
      }
    });
    this.addCommand({
      id: "test-ollama-connection",
      name: "Test Ollama Connection",
      callback: async () => {
        const connected = await this.searchService.testConnection();
        if (connected) {
          new import_obsidian4.Notice("\u2713 Connected to Ollama");
        } else {
          new import_obsidian4.Notice("\u2717 Failed to connect to Ollama. Make sure Ollama is running.");
        }
      }
    });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", async () => {
        const view = this.app.workspace.getLeavesOfType(VIEW_TYPE_RELATED_NOTES)[0]?.view;
        if (view) {
          await view.update();
        }
      })
    );
  }
  async onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_RELATED_NOTES);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_RELATED_NOTES, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
};
var RelatedNotesSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Index Statistics" });
    const statsContainer = containerEl.createDiv({ cls: "index-stats-container" });
    const totalFiles = this.plugin.app.vault.getMarkdownFiles().length;
    const currentFilePaths = new Set(this.plugin.app.vault.getMarkdownFiles().map((f) => f.path));
    const indexedFiles = this.plugin.searchService.vectors.filter((v) => currentFilePaths.has(v.path)).length;
    const missingFiles = totalFiles - indexedFiles;
    const lastIndexed = this.plugin.settings.lastIndexedDate ? new Date(this.plugin.settings.lastIndexedDate).toLocaleString() : "Never";
    const status = this.plugin.searchService.isIndexing ? "Indexing..." : "Idle";
    statsContainer.createEl("p", { text: `Status: ${status}` });
    statsContainer.createEl("p", { text: `Indexed Notes: ${indexedFiles} / ${totalFiles}`, cls: "index-stats-indexed-count" });
    statsContainer.createEl("p", { text: `Missing from Index: ${missingFiles}` });
    statsContainer.createEl("p", { text: `Last Indexed: ${lastIndexed}` });
    const buttonContainer = containerEl.createDiv({ cls: "settings-button-container" });
    new import_obsidian4.Setting(containerEl).setName("Index All Notes").setDesc("Generate embeddings for all notes in the vault. This may take a while.").addButton((button) => {
      const updateButton = () => {
        if (this.plugin.searchService.isIndexing) {
          button.setButtonText("Stop Indexing").setWarning();
        } else {
          button.setButtonText("Start Indexing").setCta();
        }
      };
      updateButton();
      button.onClick(async () => {
        if (this.plugin.searchService.isIndexing) {
          this.plugin.searchService.cancelIndexing();
          new import_obsidian4.Notice("Indexing cancelled.");
          this.display();
        } else {
          const files = this.app.vault.getMarkdownFiles();
          this.plugin.searchService.indexAll(files).then(async () => {
            this.plugin.settings.lastIndexedDate = Date.now();
            await this.plugin.saveSettings();
            new import_obsidian4.Notice("Indexing complete!");
            this.display();
          }).catch((err) => {
            if (err.message !== "Indexing cancelled") {
              console.error(err);
              new import_obsidian4.Notice("Indexing failed.");
            }
            this.display();
          });
          this.display();
        }
      });
    });
    if (this.plugin.searchService.isIndexing) {
      const progressDiv = containerEl.createDiv({ cls: "indexing-progress" });
      progressDiv.style.marginTop = "10px";
      progressDiv.style.marginBottom = "20px";
      const progressBar = progressDiv.createEl("progress");
      progressBar.style.width = "100%";
      progressBar.value = this.plugin.searchService.currentProgress;
      progressBar.max = this.plugin.searchService.totalFiles || 100;
      const progressText = progressDiv.createEl("div");
      progressText.style.textAlign = "center";
      progressText.style.fontSize = "0.8em";
      progressText.style.marginTop = "5px";
      progressText.textContent = `Indexing: ${this.plugin.searchService.currentProgress} / ${this.plugin.searchService.totalFiles}`;
      this.plugin.searchService.onIndexingProgress = (count, total) => {
        requestAnimationFrame(() => {
          progressBar.value = count;
          progressBar.max = total;
          progressText.textContent = `Indexing: ${count} / ${total}`;
          const statsEl = containerEl.querySelector(".index-stats-indexed-count");
          if (statsEl) {
            statsEl.textContent = `Indexed Notes: ${this.plugin.searchService.vectors.length} / ${total}`;
          }
        });
      };
    } else {
      this.plugin.searchService.onIndexingProgress = null;
    }
    new import_obsidian4.Setting(buttonContainer).addButton((button) => button.setButtonText("Refresh Stats").onClick(() => {
      this.display();
    }));
    containerEl.createEl("hr");
    containerEl.createEl("h2", { text: "Configuration" });
    new import_obsidian4.Setting(containerEl).setName("Ollama URL").setDesc("URL of your Ollama instance (default: http://localhost:11434)").addText((text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.ollamaUrl).onChange(async (value) => {
      this.plugin.settings.ollamaUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Embedding Model").setDesc("The Ollama model to use for generating embeddings (e.g. nomic-embed-text)").addText((text) => text.setPlaceholder("nomic-embed-text").setValue(this.plugin.settings.ollamaModel).onChange(async (value) => {
      this.plugin.settings.ollamaModel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Vector Storage Format").setDesc("Format to use for storing vectors. Binary is faster and smaller, JSON is human-readable.").addDropdown((dropdown) => dropdown.addOption("json", "JSON (Legacy)").addOption("binary", "Binary (Recommended)").setValue(this.plugin.settings.vectorFormat).onChange(async (value) => {
      this.plugin.settings.vectorFormat = value;
      this.plugin.searchService.setFormat(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Max Related Notes").setDesc("Number of related notes to display (1-20)").addSlider((slider) => slider.setLimits(1, 20, 1).setValue(this.plugin.settings.maxRelatedNotes).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxRelatedNotes = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Debug Mode").setDesc("Enable verbose logging for troubleshooting.").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
      this.plugin.settings.debugMode = value;
      this.plugin.searchService.setDebugMode(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Clear Index").setDesc("Delete the vector index and reset progress. Use this if you want to re-index from scratch.").addButton((button) => button.setButtonText("Delete Index").setWarning().onClick(async () => {
      if (confirm("Are you sure you want to delete the entire index? This cannot be undone.")) {
        await this.plugin.searchService.clearIndex();
        this.plugin.settings.lastIndexedDate = 0;
        await this.plugin.saveSettings();
        new import_obsidian4.Notice("Index deleted.");
        this.display();
      }
    }));
    new import_obsidian4.Setting(containerEl).setName("Test Connection").setDesc("Test connection to Ollama").addButton((button) => button.setButtonText("Test").onClick(async () => {
      const connected = await this.plugin.searchService.testConnection();
      if (connected) {
        new import_obsidian4.Notice("\u2713 Connected to Ollama");
      } else {
        new import_obsidian4.Notice("\u2717 Failed to connect to Ollama");
      }
    }));
  }
};
